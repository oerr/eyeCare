/* Generated by JSIL v0.8.2 build 30177. See http://jsil.org/ for more information. */ 
'use strict';
var $asm__Common_Dotnet = JSIL.DeclareAssembly("_Common_Dotnet, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");

JSIL.DeclareNamespace("System");
/* class System.EConvert */ 

(function EConvert$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm_mscorlib.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm_mscorlib.System.Exception)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm_mscorlib.System.Double)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm_mscorlib.System.Convert)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm_mscorlib.System.Int16)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm_mscorlib.System.Int32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm_mscorlib.System.Int64)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm__Common_Dotnet.SuperString.StringParser)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.Double"), [$asm_mscorlib.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.Int16"), [$asm_mscorlib.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.Int32"), [$asm_mscorlib.TypeRef("System.String")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.Int64"), [$asm_mscorlib.TypeRef("System.String")]))) ();
  };

  function EConvert__ctor () {
  };

  function EConvert_ToDouble (sVal, $exception) {
    try {
      sVal = (sVal.trim());
      sVal = (System.String.Replace(sVal, ",", ""));
      if (sVal == "") {
        sVal = "0";
      }
      var result = +$S00().CallStatic($T03(), "ToDouble", null, sVal);
    } catch ($exception) {
      result = -1;
    }
    return result;
  };

  function EConvert_ToInt16 (sVal, $exception) {
    try {
      sVal = (sVal.trim());
      sVal = (System.String.Replace(sVal, ",", ""));
      if (sVal == "") {
        sVal = "0";
      }
      var result = ($S01().CallStatic($T03(), "ToInt16", null, sVal) | 0);
    } catch ($exception) {
      result = -1;
    }
    return result;
  };

  function EConvert_ToInt32 (sVal, $exception) {
    try {
      sVal = (sVal.trim());
      sVal = (System.String.Replace(sVal, ",", ""));
      if (sVal == "") {
        sVal = "0";
      }
      var result = ($S02().CallStatic($T03(), "ToInt32", null, sVal) | 0);
    } catch ($exception) {
      result = -1;
    }
    return result;
  };

  function EConvert_ToInt64 (sVal, $exception) {
    try {
      sVal = (sVal.trim());
      sVal = (System.String.Replace(sVal, ",", ""));
      if (sVal == "") {
        sVal = "0";
      }
      var result = $S03().CallStatic($T03(), "ToInt64", null, sVal);
    } catch ($exception) {
      result = $T06()['Create'](16777215, 16777215, 65535);
    }
    return result;
  };

  function EConvert_ToString$00 (nVal, $exception) {
    try {
      var text = $T00()['Format']("{0:#,###}", nVal);
      if (text == "") {
        text = "0";
      }
      var result = text;
    } catch ($exception) {
      result = "";
    }
    return result;
  };

  function EConvert_ToString$01 (nVal, $exception) {
    try {
      var text = $T00()['Format']("{0:#,###}", nVal);
      if (text == "") {
        text = "0";
      }
      var result = text;
    } catch ($exception) {
      result = "";
    }
    return result;
  };

  function EConvert_ToString$02 (nVal, $exception) {
    try {
      var text = $T00()['Format']("{0:#,###}", nVal);
      if (text == "") {
        text = "0";
      }
      var result = text;
    } catch ($exception) {
      result = "";
    }
    return result;
  };

  function EConvert_ToString$03 (dwVal, $exception) {
    try {
      var text = $T00()['Format']("{0:0,0.000}", dwVal);
      if ((text.indexOf(".")) !== -1) {

      $loop0: 
        for (; !(!($T07()['Right'](text, 1) == "0") && !($T07()['Right'](text, 1) == ".")); text = $T07()['Left'](text, (((text.length | 0) - 1) | 0))) {
          if ($T07()['Right'](text, 1) == ".") {
            text = $T07()['Left'](text, (((text.length | 0) - 1) | 0));
            break $loop0;
          }
        }
      }

      for (var num = 0; !((num >= (text.length | 0)) || (((text[num])['charCodeAt'](0) | 0) !== (("0")['charCodeAt'](0) | 0))); num = ((num + 1) | 0)) {
      }
      if (num >= (text.length | 0)) {
        text = $T07()['Right'](text, (((text.length | 0) - ((num - 1) | 0)) | 0));
      } else if (((text[num])['charCodeAt'](0) | 0) !== ((".")['charCodeAt'](0) | 0)) {
        text = $T07()['Right'](text, (((text.length | 0) - num) | 0));
      } else {
        text = $T07()['Right'](text, (((text.length | 0) - ((num - 1) | 0)) | 0));
      }
      if (text == "") {
        text = "0";
      }
      var result = text;
    } catch ($exception) {
      result = "";
    }
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm_mscorlib.TypeRef("System.Object"), 
      Name: "System.EConvert", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EConvert__ctor
    );

    $.Method({Static:true , Public:true }, "ToDouble", 
      new JSIL.MethodSignature($.Double, [$.String]), 
      EConvert_ToDouble
    );

    $.Method({Static:true , Public:true }, "ToInt16", 
      new JSIL.MethodSignature($.Int16, [$.String]), 
      EConvert_ToInt16
    );

    $.Method({Static:true , Public:true }, "ToInt32", 
      new JSIL.MethodSignature($.Int32, [$.String]), 
      EConvert_ToInt32
    );

    $.Method({Static:true , Public:true }, "ToInt64", 
      new JSIL.MethodSignature($.Int64, [$.String]), 
      EConvert_ToInt64
    );

    $.Method({Static:true , Public:true }, "ToString", 
      new JSIL.MethodSignature($.String, [$.Int32]), 
      EConvert_ToString$00
    );

    $.Method({Static:true , Public:true }, "ToString", 
      new JSIL.MethodSignature($.String, [$.Int16]), 
      EConvert_ToString$01
    );

    $.Method({Static:true , Public:true }, "ToString", 
      new JSIL.MethodSignature($.String, [$.Int64]), 
      EConvert_ToString$02
    );

    $.Method({Static:true , Public:true }, "ToString", 
      new JSIL.MethodSignature($.String, [$.Double]), 
      EConvert_ToString$03
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("PrintToPDF");
JSIL.DeclareNamespace("PrintToPDF.Helpers");
/* class PrintToPDF.Helpers.PngEncoder */ 

(function PngEncoder$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm_mscorlib.System.Byte)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize(System.Array.Of($asm_mscorlib.System.Byte))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm_mscorlib.System.UInt32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm_mscorlib.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm_mscorlib.System.IO.MemoryStream)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm_mscorlib.System.IO.Stream)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm_mscorlib.System.BitConverter)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm_mscorlib.System.UInt16)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm_mscorlib.System.Int64)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm_mscorlib.System.IO.SeekOrigin)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm_mscorlib.TypeRef("System.IO.MemoryStream"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm_mscorlib.TypeRef("System.Byte")]), [$asm_mscorlib.TypeRef("System.Int32")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm_mscorlib.TypeRef("System.Byte")]), [$asm_mscorlib.TypeRef("System.UInt16")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm_mscorlib.TypeRef("System.Byte")]), [$asm_mscorlib.TypeRef("System.UInt32")]))) ();
  };

  function PngEncoder__ctor () {
  };

  function PngEncoder_ComputeAdler32 (buf) {
    var num = 1;
    var num2 = 0;
    var num3 = (buf.length | 0);

    for (var i = 0; i < num3; i = ((i + 1) | 0)) {
      num = ((((num + (buf[i] | 0)) >>> 0) % 65521) >>> 0);
      num2 = ((((num2 + num) >>> 0) % 65521) >>> 0);
    }
    return (((num2 << 16) + num) >>> 0);
  };

  function PngEncoder_Encode (data, width, height) {
    var memoryStream = $S00().Construct();
    memoryStream['Write']($thisType._HEADER, 0, $thisType._HEADER.length);
    var bytes = $S01().CallStatic($T06(), "GetBytes", null, width);
    $thisType._ARGB[0] = (bytes[3] | 0);
    $thisType._ARGB[1] = (bytes[2] | 0);
    $thisType._ARGB[2] = (bytes[1] | 0);
    $thisType._ARGB[3] = (bytes[0] | 0);
    bytes = $S01().CallStatic($T06(), "GetBytes", null, height);
    $thisType._ARGB[4] = (bytes[3] | 0);
    $thisType._ARGB[5] = (bytes[2] | 0);
    $thisType._ARGB[6] = (bytes[1] | 0);
    $thisType._ARGB[7] = (bytes[0] | 0);
    $thisType['WriteChunk'](memoryStream, $thisType._IHDR, $thisType._ARGB);
    bytes = $S01().CallStatic($T06(), "GetBytes", null, 100000);
    $thisType._4BYTEDATA[0] = (bytes[3] | 0);
    $thisType._4BYTEDATA[1] = (bytes[2] | 0);
    $thisType._4BYTEDATA[2] = (bytes[1] | 0);
    $thisType._4BYTEDATA[3] = (bytes[0] | 0);
    $thisType['WriteChunk'](memoryStream, $thisType._GAMA, $thisType._4BYTEDATA);
    var num = (((Math.imul(width, 4) + 1) | 0) >>> 0);
    var num2 = (Math.imul(num, (height >>> 0)) >>> 0);
    var value = ($thisType['ComputeAdler32'](data) >>> 0);
    var memoryStream2 = $S00().Construct();
    var num3 = ((65535 / num) >>> 0);
    var num4 = (Math.imul(num3, num) >>> 0);
    var num5 = num2;
    if (((num2 % num4) >>> 0) === 0) {
      var num6 = ((num2 / num4) >>> 0);
    } else {
      num6 = ((((num2 / num4) >>> 0) + 1) >>> 0);
    }
    memoryStream2['WriteByte'](120);
    memoryStream2['WriteByte'](218);

    for (var num7 = 0; num7 < num6; num7 = ((num7 + 1) >>> 0)) {
      var num8 = ((
        (num5 < num4)
           ? num5
           : num4)
       & 0xFFFF);
      if (num8 === num5) {
        memoryStream2['WriteByte'](1);
      } else {
        memoryStream2['WriteByte'](0);
      }
      memoryStream2['Write']($S02().CallStatic($T06(), "GetBytes", null, num8), 0, 2);
      memoryStream2['Write']($S02().CallStatic($T06(), "GetBytes", null, (~num8 & 0xFFFF)), 0, 2);
      memoryStream2['Write'](data, ((Math.imul(num7, num4) >>> 0) | 0), num8);
      num5 = ((num5 - num4) >>> 0);
    }
    $thisType['WriteReversedBuffer'](memoryStream2, $S03().CallStatic($T06(), "GetBytes", null, value));
    memoryStream2['Seek']($T08()['Create'](0, 0, 0), $T09().Begin);
    var array = JSIL.Array.New($T00(), memoryStream2['get_Length']());
    memoryStream2['Read'](array, 0, (memoryStream2['get_Length']())['ToNumber'](4294967295, true));
    $thisType['WriteChunk'](memoryStream, $thisType._IDAT, array);
    $thisType['WriteChunk'](memoryStream, $thisType._IEND, JSIL.Array.New($T00(), 0));
    memoryStream['Seek']($T08()['Create'](0, 0, 0), $T09().Begin);
    return memoryStream;
  };

  function PngEncoder_GetCRC (buf) {
    return (($thisType['UpdateCRC'](4294967295, buf, buf.length) >>> 0) ^ 4294967295);
  };

  function PngEncoder_MakeCRCTable () {

    for (var i = 0; i < 256; i = ((i + 1) | 0)) {
      var num = (i >>> 0);

      for (var j = 0; j < 8; j = ((j + 1) | 0)) {
        if ((num & 1) > 0) {
          num = 3988292384 ^ (num >>> 1);
        } else {
          num = num >>> 1;
        }
      }
      $thisType._crcTable[i] = num;
    }
    $thisType._crcTableComputed = true;
  };

  function PngEncoder_UpdateCRC (crc, buf, len) {
    var num = (crc >>> 0);
    if (!$thisType._crcTableComputed) {
      $thisType['MakeCRCTable']();
    }

    for (var i = 0; i < (len | 0); i = ((i + 1) | 0)) {
      num = ($thisType._crcTable[(num ^ (buf[i] | 0)) & 255] >>> 0) ^ (num >>> 8);
    }
    return num;
  };

  function PngEncoder_WriteChunk (stream, type, data) {
    var num = (type.length | 0);
    var array = JSIL.Array.New($T00(), (((type.length | 0) + (data.length | 0)) | 0));

    for (var i = 0; i < (type.length | 0); i = ((i + 1) | 0)) {
      array[i] = (type[i] | 0);
    }

    for (i = 0; i < (data.length | 0); i = ((i + 1) | 0)) {
      array[((i + num) | 0)] = (data[i] | 0);
    }
    $thisType['WriteReversedBuffer'](stream, $S01().CallStatic($T06(), "GetBytes", null, data.length));
    stream['Write'](array, 0, array.length);
    $thisType['WriteReversedBuffer'](stream, $S03().CallStatic($T06(), "GetBytes", null, $thisType['GetCRC'](array)));
  };

  function PngEncoder_WriteReversedBuffer (stream, data) {
    var num = (data.length | 0);
    var array = JSIL.Array.New($T00(), num);

    for (var i = 0; i < num; i = ((i + 1) | 0)) {
      array[i] = (data[((((num - i) | 0) - 1) | 0)] | 0);
    }
    stream['Write'](array, 0, num);
  };

  JSIL.MakeType({
      BaseType: $asm_mscorlib.TypeRef("System.Object"), 
      Name: "PrintToPDF.Helpers.PngEncoder", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      PngEncoder__ctor
    );

    $.Method({Static:true , Public:false}, "ComputeAdler32", 
      new JSIL.MethodSignature($.UInt32, [$jsilcore.TypeRef("System.Array", [$.Byte])]), 
      PngEncoder_ComputeAdler32
    );

    $.Method({Static:true , Public:true }, "Encode", 
      new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.IO.Stream"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ]), 
      PngEncoder_Encode
    );

    $.Method({Static:true , Public:false}, "GetCRC", 
      new JSIL.MethodSignature($.UInt32, [$jsilcore.TypeRef("System.Array", [$.Byte])]), 
      PngEncoder_GetCRC
    );

    $.Method({Static:true , Public:false}, "MakeCRCTable", 
      JSIL.MethodSignature.Void, 
      PngEncoder_MakeCRCTable
    );

    $.Method({Static:true , Public:false}, "UpdateCRC", 
      new JSIL.MethodSignature($.UInt32, [
          $.UInt32, $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32
        ]), 
      PngEncoder_UpdateCRC
    );

    $.Method({Static:true , Public:false}, "WriteChunk", 
      new JSIL.MethodSignature(null, [
          $asm_mscorlib.TypeRef("System.IO.Stream"), $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $jsilcore.TypeRef("System.Array", [$.Byte])
        ]), 
      PngEncoder_WriteChunk
    );

    $.Method({Static:true , Public:false}, "WriteReversedBuffer", 
      new JSIL.MethodSignature(null, [$asm_mscorlib.TypeRef("System.IO.Stream"), $jsilcore.TypeRef("System.Array", [$.Byte])]), 
      PngEncoder_WriteReversedBuffer
    );

    $['Constant']({Static:true , Public:false}, "_ADLER32_BASE", 65521); 
    $['Constant']({Static:true , Public:false}, "_MAXBLOCK", 65535); 
    $['Field']({Static:true , Public:false}, "_HEADER", $jsilcore.TypeRef("System.Array", [$.Byte])); 
    $['Field']({Static:true , Public:false}, "_IHDR", $jsilcore.TypeRef("System.Array", [$.Byte])); 
    $['Field']({Static:true , Public:false}, "_GAMA", $jsilcore.TypeRef("System.Array", [$.Byte])); 
    $['Field']({Static:true , Public:false}, "_IDAT", $jsilcore.TypeRef("System.Array", [$.Byte])); 
    $['Field']({Static:true , Public:false}, "_IEND", $jsilcore.TypeRef("System.Array", [$.Byte])); 
    $['Field']({Static:true , Public:false}, "_4BYTEDATA", $jsilcore.TypeRef("System.Array", [$.Byte])); 
    $['Field']({Static:true , Public:false}, "_ARGB", $jsilcore.TypeRef("System.Array", [$.Byte])); 
    $['Field']({Static:true , Public:false}, "_crcTable", $jsilcore.TypeRef("System.Array", [$.UInt32]), function ($pi) {
        return JSIL.Array.New($asm_mscorlib.System.UInt32, 256);
      }); 
    $['Field']({Static:true , Public:false}, "_crcTableComputed", $.Boolean, false); 
    function PngEncoder__cctor () {
      $thisType._HEADER = JSIL.Array.New($T00(), [137, 80, 78, 71, 13, 10, 26, 10]);
      $thisType._IHDR = JSIL.Array.New($T00(), [73, 72, 68, 82]);
      $thisType._GAMA = JSIL.Array.New($T00(), [103, 65, 77, 65]);
      $thisType._IDAT = JSIL.Array.New($T00(), [73, 68, 65, 84]);
      $thisType._IEND = JSIL.Array.New($T00(), [73, 69, 78, 68]);
      var 4BYTEDATA = JSIL.Array.New($T00(), 4);
      $thisType._4BYTEDATA = 4BYTEDATA;
      var array = JSIL.Array.New($T00(), 13);
      array[8] = 8;
      array[9] = 6;
      $thisType._ARGB = array;
      $thisType._crcTable = JSIL.Array.New($T02(), 256);
      $thisType._crcTableComputed = false;
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      PngEncoder__cctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("TimeChk");
/* struct TimeChk.LARGE_INTEGER */ 

(function LARGE_INTEGER$Members () {
  var $, $thisType;
  JSIL.MakeType({
      BaseType: $asm_mscorlib.TypeRef("System.ValueType"), 
      Name: "TimeChk.LARGE_INTEGER", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $['Field']({Static:false, Public:true }, "QuadPart", $.Int32); 
    $['Field']({Static:false, Public:true }, "HighPart", $.Int32); 
    $['Field']({Static:false, Public:true }, "LowPart", $.UInt32); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class TimeChk.RuntimeChk */ 

(function RuntimeChk$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm__Common_Dotnet.SuperString.StringParser)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm_mscorlib.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm__Common_Dotnet.System.EConvert)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm_mscorlib.System.Object)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.String"), [$asm_mscorlib.TypeRef("System.Double")]))) ();
  };

  function RuntimeChk__ctor () {
    this.m_sLogFilePath = "";
    this.m_sFuncName = "";
    this['Init']();
  };

  function RuntimeChk_EndChk () {
    $thisType['QueryPerformanceCounter'](/* ref */ new JSIL['MemberReference'](this, "m_tEnd"));
    this.m_RunningTime = +((+((this.m_tEnd.QuadPart | 0) - (this.m_tStart.QuadPart | 0)) / +(this.frequency.QuadPart)));
    $T00()['LogTrace'](
      $T01()['Format']("Running Time End:{0}", $S00().CallStatic($T02(), "ToString", null, this.m_RunningTime)), 
      this.m_sFuncName, 
      "RuntimeChk.cs", 
      0, 
      64, 
      this.m_sLogFilePath
    );
    return +(this.m_tEnd.QuadPart);
  };

  function RuntimeChk_Init () {
    this.m_sLogFilePath = "";
    this.m_RunningTime = 0;
    this.m_sFuncName = "";
    this.frequency.LowPart = 0;
    this.frequency.HighPart = 0;
    this.frequency.QuadPart = 0;
    this.m_tStart.LowPart = 0;
    this.m_tStart.HighPart = 0;
    this.m_tStart.QuadPart = 0;
    this.m_tEnd.LowPart = 0;
    this.m_tEnd.HighPart = 0;
    this.m_tEnd.QuadPart = 0;
  };

  function RuntimeChk_StartChk (sLogFilePath, sFunc) {
    this.m_sLogFilePath = sLogFilePath;
    this.m_sFuncName = sFunc;
    var sMsg = $T01()['Format']("Running Time Start", JSIL.Array.New($T03(), 0));
    $thisType['QueryPerformanceFrequency'](/* ref */ new JSIL['MemberReference'](this, "frequency"));
    $thisType['QueryPerformanceCounter'](/* ref */ new JSIL['MemberReference'](this, "m_tStart"));
    $T00()['LogTrace'](
      sMsg, 
      this.m_sFuncName, 
      "RuntimeChk.cs", 
      0, 
      64, 
      this.m_sLogFilePath
    );
    return +(this.m_tStart.QuadPart);
  };

  JSIL.MakeType({
      BaseType: $asm_mscorlib.TypeRef("System.Object"), 
      Name: "TimeChk.RuntimeChk", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RuntimeChk__ctor
    );

    $.Method({Static:false, Public:true }, "EndChk", 
      JSIL.MethodSignature.Return($.Double), 
      RuntimeChk_EndChk
    );

    $.Method({Static:false, Public:false}, "Init", 
      JSIL.MethodSignature.Void, 
      RuntimeChk_Init
    );

    $.PInvokeMethod({Static:true , Public:false}, "QueryPerformanceCounter", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$asm__Common_Dotnet.TypeRef("TimeChk.LARGE_INTEGER")])]), 
      {
        Module: "Kernel32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "QueryPerformanceFrequency", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$asm__Common_Dotnet.TypeRef("TimeChk.LARGE_INTEGER")])]), 
      {
        Module: "Kernel32.dll", 
      }
    );

    $.Method({Static:false, Public:true }, "StartChk", 
      new JSIL.MethodSignature($.Double, [$.String, $.String]), 
      RuntimeChk_StartChk
    );

    $['Field']({Static:false, Public:true }, "m_sLogFilePath", $.String); 
    $['Field']({Static:false, Public:true }, "m_RunningTime", $.Double); 
    $['Field']({Static:false, Public:true }, "m_sFuncName", $.String); 
    $['Field']({Static:false, Public:true }, "frequency", $asm__Common_Dotnet.TypeRef("TimeChk.LARGE_INTEGER")); 
    $['Field']({Static:false, Public:true }, "m_tStart", $asm__Common_Dotnet.TypeRef("TimeChk.LARGE_INTEGER")); 
    $['Field']({Static:false, Public:true }, "m_tEnd", $asm__Common_Dotnet.TypeRef("TimeChk.LARGE_INTEGER")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("SuperString");
/* class SuperString.StringParser */ 

(function StringParser$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm_mscorlib.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm_mscorlib.System.Boolean)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm_mscorlib.System.Convert)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm_mscorlib.System.Byte))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm_mscorlib.System.Text.Encoding)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize(System.Array.Of($asm_mscorlib.System.Char))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm_mscorlib.System.Int32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm_mscorlib.System.Char)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm_mscorlib.System.Exception)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm_mscorlib.System.Byte)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm_mscorlib.System.Object)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize(System.Array.Of($asm_mscorlib.System.String))) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm_mscorlib.System.StringSplitOptions)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm_mscorlib.System.Text.StringBuilder)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm_mscorlib.System.StringComparison)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm_mscorlib.TypeRef("System.Byte")]), [$asm_mscorlib.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.Byte"), [$asm_mscorlib.TypeRef("System.String"), $asm_mscorlib.TypeRef("System.Int32")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm_mscorlib.TypeRef("System.Text.StringBuilder"), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.Text.StringBuilder"), [$asm_mscorlib.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm_mscorlib.TypeRef("System.Int32"), [
        $asm_mscorlib.TypeRef("System.String"), $asm_mscorlib.TypeRef("System.String"), 
        $asm_mscorlib.TypeRef("System.StringComparison")
      ]))) ();
  };

  function StringParser__ctor () {
  };

  function StringParser_Base64Decode (src, bForTransfer) {
    return $thisType['Base64DecodeToString'](src, bForTransfer);
  };

  function StringParser_Base64DecodeToByte (src, bForTransfer) {
    if ($T00()['IsNullOrEmpty'](src)) {
      return null;
    }
    if (bForTransfer) {
      src = (System.String.Replace(src, "ItisPlus", "+"));
      src = (System.String.Replace(src, "ItisNeun", "="));
      src = (System.String.Replace(src, "ItisBackR", "\r"));
      src = (System.String.Replace(src, "ItisBackN", "\n"));
    }
    return $T02()['FromBase64String'](src);
  };

  function StringParser_Base64DecodeToString (src, bForTransfer) {
    if ($T00()['IsNullOrEmpty'](src)) {
      return "";
    }
    if (bForTransfer) {
      src = (System.String.Replace(src, "ItisPlus", "+"));
      src = (System.String.Replace(src, "ItisNeun", "="));
      src = (System.String.Replace(src, "ItisBackR", "\r"));
      src = (System.String.Replace(src, "ItisBackN", "\n"));
    }
    var array = $T02()['FromBase64String'](src);
    return $T04()['get_UTF8']()['GetString'](array, 0, array.length);
  };

  function StringParser_Base64Encode$00 (src, enc, bForTransfer) {
    if ($T00()['IsNullOrEmpty'](src)) {
      return "";
    }
    var bytes = $S00().CallVirtual("GetBytes", null, enc, src);
    var text = $T02()['ToBase64String'](bytes);
    if (bForTransfer) {
      text = (System.String.Replace(text, "+", "ItisPlus"));
      text = (System.String.Replace(text, "=", "ItisNeun"));
      text = (System.String.Replace(text, "\r", "ItisBackR"));
      text = (System.String.Replace(text, "\n", "ItisBackN"));
    }
    return text;
  };

  function StringParser_Base64Encode$01 (src, bForTransfer) {
    return $thisType['Base64EncodeFromString'](src, bForTransfer);
  };

  function StringParser_Base64EncodeFromByte (src, bForTransfer) {
    if (src === null) {
      return "";
    }
    var text = $T02()['ToBase64String'](src);
    if (bForTransfer) {
      text = (System.String.Replace(text, "+", "ItisPlus"));
      text = (System.String.Replace(text, "=", "ItisNeun"));
      text = (System.String.Replace(text, "\r", "ItisBackR"));
      text = (System.String.Replace(text, "\n", "ItisBackN"));
    }
    return text;
  };

  function StringParser_Base64EncodeFromString (src, bForTransfer) {
    if ($T00()['IsNullOrEmpty'](src)) {
      return "";
    }
    var bytes = $S00().CallVirtual("GetBytes", null, $T04()['get_UTF8'](), src);
    var text = $T02()['ToBase64String'](bytes);
    if (bForTransfer) {
      text = (System.String.Replace(text, "+", "ItisPlus"));
      text = (System.String.Replace(text, "=", "ItisNeun"));
      text = (System.String.Replace(text, "\r", "ItisBackR"));
      text = (System.String.Replace(text, "\n", "ItisBackN"));
    }
    return text;
  };

  function StringParser_CharToString (pszData, nSize) {
    var text = "";

    for (var i = 0; i < (nSize | 0); i = ((i + 1) | 0)) {
      var c = pszData[i];
      text = (JSIL.ConcatString(text, c));
    }
    return text;
  };

  function StringParser_ConvertANSIToUTF8forIE (sText, $exception) {
    var text = "";
    try {
      var uTF = $T04()['get_UTF8']();
      var bytes = $S00().CallVirtual("GetBytes", null, uTF, sText);
      var array = bytes;

      for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
        var b = (array[i] | 0);
        var str = $T00()['Format']("%{0:X2}", b);
        text = (JSIL.ConcatString(text, str));
      }
      var result = text;
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("<Contents>StringParser::ConvertANSIToUTF8forIE Catch Error {0}<Contents>", arg);
      result = sText;
    }
    return result;
  };

  function StringParser_Find (sSource, sFind, nStart, $exception) {
    try {
      if (sSource == "") {
        var result = -1;
      } else {
        result = (sSource.indexOf(sFind, nStart));
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::Find Catch Error:{0}", arg);
      result = -1;
    }
    return result;
  };

  function StringParser_FindEx (sSource, sFind, cSysBase, /* ref */ sFBase, nStart, $exception) {
    var flag = false;
    sFBase.set("");
    try {
      if (((sFind[(((sFind.length | 0) - 1) | 0)])['charCodeAt'](0) | 0) === (cSysBase['charCodeAt'](0) | 0)) {
        sFind = $thisType['Left'](sFind, (((sFind.length | 0) - 1) | 0));
      }
      var length = (sSource.length | 0);
      var length2 = (sFind.length | 0);
      if (length <= (nStart | 0)) {
        var result = -1;
      } else {
        var i = (nStart | 0);
        var num = 0;

        while (i < length) {

        $loop1: 
          for (var j = 0; j < length2; j = ((j + 1) | 0)) {
            if (((i + num) | 0) >= length) {
              j = (sFind.length | 0);
              break $loop1;
            }
            if (((sSource[((i + num) | 0)])['charCodeAt'](0) | 0) !== ((sFind[j])['charCodeAt'](0) | 0)) {
              if ((j >= length2) || (((sFind[j])['charCodeAt'](0) | 0) === (cSysBase['charCodeAt'](0) | 0))) {
                num = 0;
                flag = true;
                break $loop1;
              }
              num = 0;
              j = ($thisType['GoToNextBase'](j, sFind, cSysBase) | 0);
              if (j === -1) {
                break $loop1;
              }
            } else {
              num = ((num + 1) | 0);
            }
          }
          if (!(!flag && (j === -1))) {
            var num2 = 0;
            var num3 = ((j - 1) | 0);

          $loop2: 
            while (j > 0) {
              if (((sFind[(j = ((j - 1) | 0))])['charCodeAt'](0) | 0) === (cSysBase['charCodeAt'](0) | 0)) {
                num2 = ((j + 1) | 0);
                break $loop2;
              }
            }
            num3 = ((((num3 - num2) | 0) + 1) | 0);
            sFBase.set($thisType['Mid'](sFind, num2, num3));
            result = i;
            return result;
          }
          i = ((i + 1) | 0);
        }
        result = -1;
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::FindEx Catch Error:{0}", arg);
      result = -1;
    }
    return result;
  };

  function StringParser_FindNoCase (sSource, sFind, nStart, $exception) {
    try {
      if (sSource == "") {
        var result = -1;
      } else {
        sSource = (sSource.toLowerCase());
        sFind = (sFind.toLowerCase());
        result = (sSource.indexOf(sFind, nStart));
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::FindNoCase Catch Error:{0}", arg);
      result = -1;
    }
    return result;
  };

  function StringParser_FromHexString (hexString, $exception) {
    try {
      var array = JSIL.Array.New($T09(), (((hexString.length | 0) / 2) | 0));

      for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
        array[i] = ($S01().CallStatic($T02(), "ToByte", null, hexString.substr(Math.imul(i, 2), 2), 16) | 0);
      }
      var result = $T04()['get_Unicode']()['GetString'](array);
    } catch ($exception) {
      result = "";
    }
    return result;
  };

  function StringParser_GetIndexofSearch (sSource, sObject, sBase, $exception) {
    try {
      var num = 0;
      var array = (JSIL.SplitString(sSource, JSIL.Array.New($T00(), [sBase]), $T0C().None));
      var array2 = array;

      for (var i = 0; i < (array2.length | 0); i = ((i + 1) | 0)) {
        var a = array2[i];
        num = ((num + 1) | 0);
        if (a == sObject) {
          return num;
        }
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::GetIndexofSearch Catch Error:{0}", arg);
    }
    return -1;
  };

  function StringParser_GetJustPath (szSource, $exception) {
    try {
      var text = szSource;
      if (text == "") {
        var result = "";
      } else {
        if ((text.indexOf("\\")) !== -1) {
          var text2 = "\\";
        } else {
          if ((text.indexOf("/")) === -1) {
            result = szSource;
            return result;
          }
          text2 = "/";
        }
        var strCount = ($thisType['GetStrCount'](text, text2) | 0);
        var text3 = $thisType['GetNthStr'](text, strCount, text2);
        if (!(((text3.indexOf(".")) === -1) && 
            ((text3.indexOf("*")) === -1) && ((text3.indexOf("?")) === -1))) {
          text = $thisType['Replace'](text, strCount, text2, "");
        }
        if (text == "") {
          result = text;
        } else {
          text3 = (text[(((text.length | 0) - 1) | 0)])['toString']();
          if (text3 != text2) {
            text = (JSIL.ConcatString(text, text2));
          }
          result = text;
        }
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::GetJustPath Catch Error:{0}", arg);
      result = "Error";
    }
    return result;
  };

  function StringParser_GetLineData (sBuf, nFromIndex, /* ref */ nNextIndex, $exception) {
    var text = "";
    try {
      nNextIndex.set(-1);
      if (sBuf == "") {
        var result = "";
      } else {
        var length = (sBuf.length | 0);

        for (var i = (nFromIndex | 0); i < length; i = ((i + 1) | 0)) {
          if ((((sBuf[i])['charCodeAt'](0) | 0) === (("\r")['charCodeAt'](0) | 0)) || (((sBuf[i])['charCodeAt'](0) | 0) === (("\n")['charCodeAt'](0) | 0))) {

            for (; i < length; i = ((i + 1) | 0)) {
              if ((((sBuf[i])['charCodeAt'](0) | 0) !== (("\r")['charCodeAt'](0) | 0)) && (((sBuf[i])['charCodeAt'](0) | 0) !== (("\n")['charCodeAt'](0) | 0))) {
                nNextIndex.set(i);
                text = (text.trim());
                result = text;
                return result;
              }
            }
            nNextIndex.set(i);
            result = text;
            return result;
          }
          text = (JSIL.ConcatString(text, sBuf[i]));
        }
        nNextIndex.set(i);
        result = text;
      }
    } catch ($exception) {
      nNextIndex.set(0);
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::GetLineData Catch Error:{0}", arg);
      result = "";
    }
    return result;
  };

  function StringParser_GetNthStr (sSource, nFrom, sBase, $exception) {
    try {
      var array = (JSIL.SplitString(sSource, JSIL.Array.New($T00(), [sBase]), $T0C().None));
      var result = array[(((nFrom | 0) - 1) | 0)];
    } catch ($exception) {
      result = "";
    }
    return result;
  };

  function StringParser_GetNthStrEx (sSource, nFrom, sBase, cFBase, /* ref */ sOutBase) {
    sOutBase.set("");
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    var num3 = new JSIL.BoxedVariable(0);
    return $thisType['GetStrFromStrEx'](
      sSource, 
      nFrom, 
      sBase, 
      cFBase, 
      /* ref */ sOutBase, 
      /* ref */ num, 
      /* ref */ num2, 
      /* ref */ num3
    );
  };

  function StringParser_GetNthStrNoCase (szSource, nFrom, sBase) {
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    var num3 = new JSIL.BoxedVariable(0);
    return $thisType['GetStrFromStrNoCase'](
      szSource, 
      nFrom, 
      sBase, 
      /* ref */ num, 
      /* ref */ num2, 
      /* ref */ num3
    );
  };

  function StringParser_GetParseAt (nIdx) {
    if ((nIdx | 0) >= (this.m_aParse.length | 0)) {
      return "";
    }
    return this.m_aParse[nIdx];
  };

  function StringParser_GetParseCount () {
    if (!(this.m_aParse[(((this.m_aParse.length | 0) - 1) | 0)] == "")) {
      return this.m_aParse.length;
    }
    return (((this.m_aParse.length | 0) - 1) | 0);
  };

  function StringParser_GetStrCount (sSource, sBase) {
    var array = (JSIL.SplitString(sSource, JSIL.Array.New($T00(), [sBase]), $T0C().None));
    if (!(array[(((array.length | 0) - 1) | 0)] == "")) {
      return array.length;
    }
    return (((array.length | 0) - 1) | 0);
  };

  function StringParser_GetStrCountEx (sSource, sBase, cFBase) {
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    var result = new JSIL.BoxedVariable(0);
    var text = new JSIL.BoxedVariable("");
    $thisType['GetStrFromStrEx'](
      sSource, 
      -1, 
      sBase, 
      cFBase, 
      /* ref */ text, 
      /* ref */ num, 
      /* ref */ num2, 
      /* ref */ result
    );
    return result.get();
  };

  function StringParser_GetStrCountNoCase (sSource, sBase) {
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    var result = new JSIL.BoxedVariable(0);
    $thisType['GetStrFromStrNoCase'](
      sSource, 
      -1, 
      sBase, 
      /* ref */ num, 
      /* ref */ num2, 
      /* ref */ result
    );
    return result.get();
  };

  function StringParser_GetStrFromStr (sSource, nFrom, sBase, /* ref */ nSiteFrom, /* ref */ nSiteTo, /* ref */ nCnt, $exception) {
    var text = "";
    var num = 0;
    var i = 0;
    var num2 = 0;
    nSiteFrom.set(0);
    nSiteTo.set(0);
    nCnt.set(0);
    try {
      if ($T00()['IsNullOrEmpty'](sSource)) {
        nCnt.set(0);
        var result = "";
      } else if ((sBase.length | 0) > (sSource.length | 0)) {
        nCnt.set(1);
        result = sSource;
      } else {
        var length = (sSource.length | 0);
        var length2 = (sBase.length | 0);
        if ((sSource.indexOf(sBase, ((length - length2) | 0))) === -1) {
          sSource = (JSIL.ConcatString(sSource, sBase));
        }

      $loop0: 
        while (i < length) {
          i = (sSource.indexOf(sBase, i));
          if (i === -1) {
            break $loop0;
          }
          num = ((num + 1) | 0);
          if (num === (nFrom | 0)) {
            text = (JSIL.ConcatString(text, sSource.substr(num2, ((i - num2) | 0))));
            break $loop0;
          }
          i = ((i + length2) | 0);
          num2 = i;
        }
        nSiteFrom.set(num2);
        nSiteTo.set(((i - 1) | 0));
        nCnt.set(num);
        result = text;
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::GetStrFromStr Catch Error:{0}", arg);
      result = "";
    }
    return result;
  };

  function StringParser_GetStrFromStrEx (sSource, nFrom, sBase, cFBase, /* ref */ soutBase, /* ref */ nSiteFrom, /* ref */ nSiteTo, /* ref */ nCount, $exception) {
    var text = "";
    var text2 = "";
    var text3 = new JSIL.BoxedVariable("");
    var num = 0;
    var i = 0;
    var num2 = 0;
    try {
      soutBase.set("");
      nSiteFrom.set(0);
      nSiteTo.set(0);
      nCount.set(0);
      var text4 = sSource;
      if (text4 == "") {
        nCount.set(0);
        var result = "";
      } else {
        var length = (text4.length | 0);
        var length2 = (sBase.length | 0);
        var num3 = 0;
        var array = (JSIL.SplitString(sBase, JSIL.Array.New($T07(), [cFBase])));
        var strCount = ($thisType['GetStrCount'](sBase, cFBase['toString']()) | 0);
        var array2 = array;

      $loop0: 
        for (var j = 0; j < (array2.length | 0); j = ((j + 1) | 0)) {
          var text5 = array2[j];
          num3 = ((num3 + 1) | 0);
          text = text5;
          if ((text4.indexOf(sBase, ((length - (text.length | 0)) | 0))) !== -1) {
            break $loop0;
          }
        }
        if (num3 >= strCount) {
          text4 = (JSIL.ConcatString(text4, text));
        }

      $loop1: 
        while (i < length) {
          i = ($thisType['FindEx'](
            text4, 
            sBase, 
            cFBase, 
            /* ref */ text3, 
            i
          ) | 0);
          length2 = (text3.get().length | 0);
          if (i === -1) {
            break $loop1;
          }
          num = ((num + 1) | 0);
          if (num === (nFrom | 0)) {

            for (var k = num2; k < i; k = ((k + 1) | 0)) {
              text2 = (JSIL.ConcatString(text2, text4[k]));
            }
            break $loop1;
          }
          i = ((i + length2) | 0);
          num2 = i;
        }
        nSiteFrom.set(num2);
        nSiteTo.set(((i - 1) | 0));
        nCount.set(num);
        soutBase.set(text3.get());
        result = text2;
      }
    } catch ($exception) {
      soutBase.set("");
      nSiteFrom.set(0);
      nSiteTo.set(0);
      nCount.set(0);
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::GetStrFromStrEx Catch Error:{0}", arg);
      result = "";
    }
    return result;
  };

  function StringParser_GetStrFromStrNoCase (sSource, nFrom, sBase, /* ref */ nSiteFrom, /* ref */ nSiteTo, /* ref */ nCnt, $exception) {
    var text = "";
    var num = 0;
    var i = 0;
    var num2 = 0;
    try {
      nSiteFrom.set(0);
      nSiteTo.set(0);
      nCnt.set(0);
      var text2 = sSource;
      if (text2 == "") {
        nCnt.set(0);
        var result = "";
      } else if ((sBase.length | 0) > (text2.length | 0)) {
        nCnt.set(1);
        result = text2;
      } else {
        var length = (text2.length | 0);
        var length2 = (sBase.length | 0);
        if (($thisType['FindNoCase'](text2, sBase, ((length - length2) | 0)) | 0) === -1) {
          text2 = (JSIL.ConcatString(text2, sBase));
        }

      $loop0: 
        while (i < length) {
          i = ($thisType['FindNoCase'](text2, sBase, i) | 0);
          if (i === -1) {
            break $loop0;
          }
          num = ((num + 1) | 0);
          if (num === (nFrom | 0)) {

            for (var j = num2; j < i; j = ((j + 1) | 0)) {
              text = (JSIL.ConcatString(text, text2[j]));
            }
            break $loop0;
          }
          i = ((i + length2) | 0);
          num2 = i;
        }
        nSiteFrom.set(num2);
        nSiteTo.set(((i - 1) | 0));
        nCnt.set(num);
        result = text;
      }
    } catch ($exception) {
      nSiteFrom.set(0);
      nSiteTo.set(0);
      nCnt.set(0);
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::GetStrFromStrNoCase Catch Error:{0}", arg);
      result = "";
    }
    return result;
  };

  function StringParser_GoToNextBase (i, sFind, cSysBase) {
    return sFind.indexOf(cSysBase, (((i | 0) + 1) | 0));
  };

  function StringParser_InsertAt (sData, nIndex, sBase, sInsertData, $exception) {
    var startIndex = new JSIL.BoxedVariable(0);
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    try {
      $thisType['GetStrFromStr'](
        sData, 
        nIndex, 
        sBase, 
        /* ref */ startIndex, 
        /* ref */ num, 
        /* ref */ num2
      );
      var value = $T00()['Format']("{0}{1}", sInsertData, sBase);
      sData = (System.String.Insert(sData, startIndex.get(), value));
      var result = sData;
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::InsertAt Catch Error:{0}", arg);
      result = "";
    }
    return result;
  };

  function StringParser_IsAlphaChar (cCh) {
    return ((((cCh['charCodeAt'](0) | 0) >= (("A")['charCodeAt'](0) | 0)) && 
        ((cCh['charCodeAt'](0) | 0) <= (("Z")['charCodeAt'](0) | 0))) || (((cCh['charCodeAt'](0) | 0) >= (("a")['charCodeAt'](0) | 0)) && 
        ((cCh['charCodeAt'](0) | 0) <= (("z")['charCodeAt'](0) | 0))));
  };

  function StringParser_IsAlphaStr (sString, $exception) {
    try {
      var length = (sString.length | 0);
      if (length <= 0) {
        var result = false;
      } else {

        for (var i = 0; i < length; i = ((i + 1) | 0)) {
          if (!($thisType['IsAlphaChar'](sString[i]) || $thisType['IsETCChar'](sString[i]))) {
            result = false;
            return result;
          }
        }
        result = true;
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::IsAlphaStr Catch Error:{0}", arg);
      result = false;
    }
    return result;
  };

  function StringParser_IsDigitChar (cCh) {
    return (((cCh['charCodeAt'](0) | 0) >= (("0")['charCodeAt'](0) | 0)) && ((cCh['charCodeAt'](0) | 0) <= (("9")['charCodeAt'](0) | 0)));
  };

  function StringParser_IsDigitStr (sString, $exception) {
    try {
      var length = (sString.length | 0);
      if (length <= 0) {
        var result = false;
      } else {

        for (var i = 0; i < length; i = ((i + 1) | 0)) {
          if (!$thisType['IsDigitChar'](sString[i])) {
            result = false;
            return result;
          }
        }
        result = true;
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::IsDigitStr Catch Error:{0}", arg);
      result = false;
    }
    return result;
  };

  function StringParser_IsDomain (sData, $exception) {
    try {
      if (sData == "") {
        var result = false;
      } else {
        sData = (sData.trim());
        var nthStr = $thisType['GetNthStr'](sData, 1, "//");
        if ((nthStr.indexOf(":")) !== -1) {
          System.String.Replace(sData, JSIL.ConcatString(nthStr, "//"), "");
        } else {
          sData = nthStr;
        }
        sData = $thisType['GetNthStr'](sData, 1, "/");
        var strCount = ($thisType['GetStrCount'](sData, ".") | 0);
        if (!((strCount < 2) || (strCount > 4))) {
          if (!(!$thisType['IsDigitStr']($thisType['GetNthStr'](sData, 1, ".")) || 
              !$thisType['IsDigitStr']($thisType['GetNthStr'](sData, 2, ".")) || !$thisType['IsDigitStr']($thisType['GetNthStr'](sData, 3, ".")))) {
            var nthStr2 = $thisType['GetNthStr'](sData, 4, ".");
            nthStr2 = $thisType['GetNthStr'](nthStr2, 1, ":");
            if ($thisType['IsDigitStr'](nthStr2)) {
              result = true;
              return result;
            }
          }
          nthStr2 = $thisType['GetNthStr'](sData, strCount, ".");
          nthStr2 = $thisType['GetNthStr'](nthStr2, 1, ":");
          if (!$thisType['IsAlphaStr'](nthStr2)) {
            result = false;
          } else {
            nthStr2 = $thisType['GetNthStr'](sData, 1, ".");
            result = $thisType['IsAlphaChar'](nthStr2[0]) || 
            $thisType['IsDigitChar'](nthStr2[0]);
          }
        } else {
          result = (sData == "localhost") || 
          ((sData.indexOf("localhost:")) !== -1);
        }
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::IsDomain Catch Error:{0}", arg);
      result = false;
    }
    return result;
  };

  function StringParser_IsETCChar (cCh) {
    return (((cCh['charCodeAt'](0) | 0) === (("-")['charCodeAt'](0) | 0)) || 
      ((cCh['charCodeAt'](0) | 0) === (("[")['charCodeAt'](0) | 0)) || 
      ((cCh['charCodeAt'](0) | 0) === (("]")['charCodeAt'](0) | 0)) || 
      ((cCh['charCodeAt'](0) | 0) === (("^")['charCodeAt'](0) | 0)) || 
      ((cCh['charCodeAt'](0) | 0) === (("_")['charCodeAt'](0) | 0)) || ((cCh['charCodeAt'](0) | 0) === (("`")['charCodeAt'](0) | 0)));
  };

  function StringParser_IsFindSqlInjuction (sData) {
    return (((sData.indexOf(";")) !== -1) || 
      ((sData.indexOf("+")) !== -1) || 
      ((sData.indexOf("#")) !== -1) || 
      ((sData.indexOf("--")) !== -1) || 
      ((sData.indexOf("'")) !== -1) || 
      (($thisType['FindNoCase'](sData, "UNION", 0) | 0) !== -1) || 
      (($thisType['FindNoCase'](sData, "SELECT", 0) | 0) !== -1) || 
      (($thisType['FindNoCase'](sData, "INSERT", 0) | 0) !== -1) || (($thisType['FindNoCase'](sData, "UPDATE", 0) | 0) !== -1));
  };

  function StringParser_Left (str, len) {
    if ((str.length | 0) < (len | 0)) {
      len = (str.length | 0);
    }
    return str.substr(0, len);
  };

  function StringParser_LogTrace$02 (sMsg, sFilePath, nLine, nEventType, sLogFilePath) {
    return $thisType['LogTrace'](
      sMsg, 
      "", 
      sFilePath, 
      nLine, 
      nEventType, 
      sLogFilePath
    );
  };

  function StringParser_LogTrace$03 (sMsg, sFunc, sFilePath, nLine, nEventType, sLogFilePath) {
    return $thisType['LogTrace'](
      sMsg, 
      sFunc, 
      1, 
      sFilePath, 
      nLine, 
      nEventType, 
      sLogFilePath
    );
  };

  function StringParser_LogTrace$04 (sMsg, sFunc, nEvtID, sFilePath, nLine, nEventType, sLogFilePath, $exception) {
    try {
      var result = true;
    } catch ($exception) {
      result = false;
    }
    return result;
  };

  function StringParser_Mid$05 (str, startInt, endInt) {
    if (!(((startInt | 0) >= (str.length | 0)) && ((endInt | 0) >= (str.length | 0)))) {
      return str.substr(startInt, endInt);
    }
    return str;
  };

  function StringParser_Mid$06 (str, startInt) {
    var num = (((str.length | 0) - (startInt | 0)) | 0);
    if (!(((startInt | 0) >= (str.length | 0)) && (num >= (str.length | 0)))) {
      return str.substr(startInt, num);
    }
    return str;
  };

  function StringParser_Parse (sSrc, sBase) {
    this.m_aParse = (JSIL.SplitString(sSrc, JSIL.Array.New($T00(), [sBase]), $T0C().None));
    if (!(this.m_aParse[(((this.m_aParse.length | 0) - 1) | 0)] == "")) {
      return this.m_aParse.length;
    }
    return (((this.m_aParse.length | 0) - 1) | 0);
  };

  function StringParser_RemoveAllParse () {
    this.m_aParse = JSIL.Array.New($T00(), 0);
  };

  function StringParser_Replace (sSource, nFrom, sBase, sCharSet, $exception) {
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    var num3 = new JSIL.BoxedVariable(0);
    try {
      var text = sSource;
      if (text == "") {
        var result = "";
      } else {
        var length = (text.length | 0);
        var length2 = (sBase.length | 0);
        var flag = false;
        if ((text.indexOf(sBase, ((length - length2) | 0))) === -1) {
          flag = true;
          text = (JSIL.ConcatString(text, sBase));
        }
        $thisType['GetStrFromStr'](
          text, 
          nFrom, 
          sBase, 
          /* ref */ num, 
          /* ref */ num2, 
          /* ref */ num3
        );
        var count = (((((((num2.get() | 0) - (num.get() | 0)) | 0) + length2) | 0) + 1) | 0);
        text = (System.String.Remove(text, num.get(), count));
        if (text != "") {
          if (sCharSet != "") {
            text = (System.String.Insert(text, num.get(), JSIL.ConcatString(sCharSet, sBase)));
          }
          if (flag) {
            text = $thisType['Left'](text, (((text.length | 0) - length2) | 0));
          }
        }
        result = text;
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::Replace Catch Error:{0}", arg);
      result = "Error";
    }
    return result;
  };

  function StringParser_Right (str, len) {
    if ((str.length | 0) < (len | 0)) {
      len = (str.length | 0);
    }
    return str.substr((((str.length | 0) - (len | 0)) | 0), len);
  };

  function StringParser_SetParseAt (nIdx, sData) {
    if ((nIdx | 0) >= (this.m_aParse.length | 0)) {
      return;
    }
    this.m_aParse[nIdx] = sData;
  };

  function StringParser_StringToChar (sData, /* ref */ nSize, $exception) {
    try {
      nSize.set(0);
      if (sData == "") {
        var result = null;
      } else {
        var array = JSIL.Array.New($T07(), (((sData.length | 0) + 1) | 0));

        for (var i = 0; i < (sData.length | 0); i = ((i + 1) | 0)) {
          array[i] = (sData[i]);
        }
        nSize.set(sData.length);
        result = array;
      }
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::StringToByte Catch Error:{0}", arg);
      nSize.set(-1);
      result = null;
    }
    return result;
  };

  function StringParser_ToHexString (str, $exception) {
    try {
      var stringBuilder = $S02().Construct();
      var bytes = $S00().CallVirtual("GetBytes", null, $T04()['get_Unicode'](), str);
      var array = bytes;

      for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
        var b = (array[i] | 0);
        $S03().CallVirtual("Append", null, stringBuilder, JSIL.NumberToFormattedString(b, null, "X2"));
      }
      var result = stringBuilder['toString']();
    } catch ($exception) {
      result = "";
    }
    return result;
  };

  function StringParser_WildcardCompare (strWild, strText, $exception) {
    var $temp00;
    var num = 0;
    var num2 = 0;
    var num3 = 0;
    var i = 0;
    var length = (strText.length | 0);
    var length2 = (strWild.length | 0);
    try {
      if (((strWild.indexOf("*")) !== -1) || ((strWild.indexOf("?")) !== -1)) {

        var $label0 = 0;
      $labelgroup0: 
        while (true) {
          switch ($label0) {
            case 0: /* $entry0 */ 

              for (; i < length; i = ((i + 1) | 0)) {
                if ((num3 >= length2) || (((strWild[num3])['charCodeAt'](0) | 0) === (("*")['charCodeAt'](0) | 0))) {
                  $label0 = 1 /* goto IL_DD */ ;
                  continue $labelgroup0;
                }
                if (!((((strWild[num3])['charCodeAt'](0) | 0) === ((strText[i])['charCodeAt'](0) | 0)) || (((strWild[num3])['charCodeAt'](0) | 0) === (("?")['charCodeAt'](0) | 0)))) {
                  var result = false;
                  return result;
                }
                num3 = ((num3 + 1) | 0);
              }
              $label0 = 1 /* goto IL_DD */ ;
              continue $labelgroup0;

            case 1: /* IL_DD */ 
            $entry1: 

              while (i < length) {
                if (num3 >= length2) {
                  $label0 = 2 /* goto IL_F3 */ ;
                  continue $labelgroup0;
                }
                if (((strWild[num3])['charCodeAt'](0) | 0) === (("*")['charCodeAt'](0) | 0)) {
                  num3 = ((num3 + 1) | 0);
                  if (num3 >= length2) {
                    result = true;
                    return result;
                  }
                  num2 = num3;
                  num = ((i + 1) | 0);
                } else if (!((((strWild[num3])['charCodeAt'](0) | 0) !== ((strText[i])['charCodeAt'](0) | 0)) && (((strWild[num3])['charCodeAt'](0) | 0) !== (("?")['charCodeAt'](0) | 0)))) {
                  num3 = ((num3 + 1) | 0);
                  i = ((i + 1) | 0);
                } else {
                  num3 = num2;
                  i = (($temp00 = num, 
                    num = ((num + 1) | 0), 
                    $temp00) | 0);
                }
              }
              $label0 = 2 /* goto IL_F3 */ ;
              continue $labelgroup0;

              $label0 = 2 /* goto IL_F3 */ ;
              continue $labelgroup0;
            case 2: /* IL_F3 */ 

              for (; !((num3 >= length2) || (((strWild[num3])['charCodeAt'](0) | 0) !== (("*")['charCodeAt'](0) | 0))); num3 = ((num3 + 1) | 0)) {
              }
              result = num3 >= length2;
              return result;

              break $labelgroup0;
          }
        }
      }
      result = (strWild == strText);
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::WildcardCompare Catch Error:{0}", arg);
      result = false;
    }
    return result;
  };

  function StringParser_WildcardCompareNoCase (strWild, strText, $exception) {
    var $temp00;
    var num = 0;
    var num2 = 0;
    var num3 = 0;
    var i = 0;
    var length = (strText.length | 0);
    var length2 = (strWild.length | 0);
    try {
      if (((strWild.indexOf("*")) !== -1) || ((strWild.indexOf("?")) !== -1)) {

        var $label0 = 0;
      $labelgroup0: 
        while (true) {
          switch ($label0) {
            case 0: /* $entry0 */ 

              for (; i < length; i = ((i + 1) | 0)) {
                if ((num3 >= length2) || (((strWild[num3])['charCodeAt'](0) | 0) === (("*")['charCodeAt'](0) | 0))) {
                  $label0 = 1 /* goto IL_12C */ ;
                  continue $labelgroup0;
                }
                if (!(!((strWild[num3])['toString']().toUpperCase() != (strText[i])['toString']().toUpperCase()) || (((strWild[num3])['charCodeAt'](0) | 0) === (("?")['charCodeAt'](0) | 0)))) {
                  var result = false;
                  return result;
                }
                num3 = ((num3 + 1) | 0);
              }
              $label0 = 1 /* goto IL_12C */ ;
              continue $labelgroup0;

            case 1: /* IL_12C */ 
            $entry1: 

              while (i < length) {
                if (num3 >= length2) {
                  $label0 = 2 /* goto IL_142 */ ;
                  continue $labelgroup0;
                }
                if (((strWild[num3])['charCodeAt'](0) | 0) === (("*")['charCodeAt'](0) | 0)) {
                  num3 = ((num3 + 1) | 0);
                  if (num3 >= length2) {
                    result = true;
                    return result;
                  }
                  num2 = num3;
                  num = ((i + 1) | 0);
                } else if (!(!((strWild[num3])['toString']().toUpperCase() == (strText[i])['toString']().toUpperCase()) && (((strWild[num3])['charCodeAt'](0) | 0) !== (("?")['charCodeAt'](0) | 0)))) {
                  num3 = ((num3 + 1) | 0);
                  i = ((i + 1) | 0);
                } else {
                  num3 = num2;
                  i = (($temp00 = num, 
                    num = ((num + 1) | 0), 
                    $temp00) | 0);
                }
              }
              $label0 = 2 /* goto IL_142 */ ;
              continue $labelgroup0;

              $label0 = 2 /* goto IL_142 */ ;
              continue $labelgroup0;
            case 2: /* IL_142 */ 

              for (; !((num3 >= length2) || (((strWild[num3])['charCodeAt'](0) | 0) !== (("*")['charCodeAt'](0) | 0))); num3 = ((num3 + 1) | 0)) {
              }
              result = num3 >= length2;
              return result;

              break $labelgroup0;
          }
        }
      }
      result = ($S04().CallStatic($T00(), "Compare", null, strWild, strText, $T0E().OrdinalIgnoreCase) | 0) === 0;
    } catch ($exception) {
      var arg = $exception['toString']();
      $T00()['Format']("StringParser::WildcardCompareNoCase Catch Error:{0}", arg);
      result = false;
    }
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm_mscorlib.TypeRef("System.Object"), 
      Name: "SuperString.StringParser", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      StringParser__ctor
    );

    $.Method({Static:true , Public:true }, "Base64Decode", 
      new JSIL.MethodSignature($.String, [$.String, $.Boolean]), 
      StringParser_Base64Decode
    );

    $.Method({Static:true , Public:true }, "Base64DecodeToByte", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Byte]), [$.String, $.Boolean]), 
      StringParser_Base64DecodeToByte
    );

    $.Method({Static:true , Public:true }, "Base64DecodeToString", 
      new JSIL.MethodSignature($.String, [$.String, $.Boolean]), 
      StringParser_Base64DecodeToString
    );

    $.Method({Static:true , Public:true }, "Base64Encode", 
      new JSIL.MethodSignature($.String, [
          $.String, $asm_mscorlib.TypeRef("System.Text.Encoding"), 
          $.Boolean
        ]), 
      StringParser_Base64Encode$00
    );

    $.Method({Static:true , Public:true }, "Base64Encode", 
      new JSIL.MethodSignature($.String, [$.String, $.Boolean]), 
      StringParser_Base64Encode$01
    );

    $.Method({Static:true , Public:true }, "Base64EncodeFromByte", 
      new JSIL.MethodSignature($.String, [$jsilcore.TypeRef("System.Array", [$.Byte]), $.Boolean]), 
      StringParser_Base64EncodeFromByte
    );

    $.Method({Static:true , Public:true }, "Base64EncodeFromString", 
      new JSIL.MethodSignature($.String, [$.String, $.Boolean]), 
      StringParser_Base64EncodeFromString
    );

    $.Method({Static:true , Public:true }, "CharToString", 
      new JSIL.MethodSignature($.String, [$jsilcore.TypeRef("System.Array", [$.Char]), $.Int32]), 
      StringParser_CharToString
    );

    $.Method({Static:true , Public:true }, "ConvertANSIToUTF8forIE", 
      new JSIL.MethodSignature($.String, [$.String]), 
      StringParser_ConvertANSIToUTF8forIE
    );

    $.Method({Static:true , Public:true }, "Find", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $.Int32
        ]), 
      StringParser_Find
    );

    $.Method({Static:true , Public:true }, "FindEx", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $.Char, $jsilcore.TypeRef("JSIL.Reference", [$.String]), 
          $.Int32
        ]), 
      StringParser_FindEx
    );

    $.Method({Static:true , Public:true }, "FindNoCase", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $.Int32
        ]), 
      StringParser_FindNoCase
    );

    $.Method({Static:true , Public:true }, "FromHexString", 
      new JSIL.MethodSignature($.String, [$.String]), 
      StringParser_FromHexString
    );

    $.Method({Static:true , Public:true }, "GetIndexofSearch", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $.String
        ]), 
      StringParser_GetIndexofSearch
    );

    $.Method({Static:true , Public:true }, "GetJustPath", 
      new JSIL.MethodSignature($.String, [$.String]), 
      StringParser_GetJustPath
    );

    $.Method({Static:true , Public:true }, "GetLineData", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      StringParser_GetLineData
    );

    $.Method({Static:true , Public:true }, "GetNthStr", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String
        ]), 
      StringParser_GetNthStr
    );

    $.Method({Static:true , Public:true }, "GetNthStrEx", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String, $.Char, 
          $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ]), 
      StringParser_GetNthStrEx
    );

    $.Method({Static:true , Public:true }, "GetNthStrNoCase", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String
        ]), 
      StringParser_GetNthStrNoCase
    );

    $.Method({Static:false, Public:true }, "GetParseAt", 
      new JSIL.MethodSignature($.String, [$.Int32]), 
      StringParser_GetParseAt
    );

    $.Method({Static:false, Public:true }, "GetParseCount", 
      JSIL.MethodSignature.Return($.Int32), 
      StringParser_GetParseCount
    );

    $.Method({Static:true , Public:true }, "GetStrCount", 
      new JSIL.MethodSignature($.Int32, [$.String, $.String]), 
      StringParser_GetStrCount
    );

    $.Method({Static:true , Public:true }, "GetStrCountEx", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $.Char
        ]), 
      StringParser_GetStrCountEx
    );

    $.Method({Static:true , Public:true }, "GetStrCountNoCase", 
      new JSIL.MethodSignature($.Int32, [$.String, $.String]), 
      StringParser_GetStrCountNoCase
    );

    $.Method({Static:true , Public:true }, "GetStrFromStr", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      StringParser_GetStrFromStr
    );

    $.Method({Static:true , Public:true }, "GetStrFromStrEx", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String, $.Char, 
          $jsilcore.TypeRef("JSIL.Reference", [$.String]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      StringParser_GetStrFromStrEx
    );

    $.Method({Static:true , Public:true }, "GetStrFromStrNoCase", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      StringParser_GetStrFromStrNoCase
    );

    $.Method({Static:true , Public:true }, "GoToNextBase", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $.String, 
          $.Char
        ]), 
      StringParser_GoToNextBase
    );

    $.Method({Static:true , Public:true }, "InsertAt", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String, $.String
        ]), 
      StringParser_InsertAt
    );

    $.Method({Static:true , Public:true }, "IsAlphaChar", 
      new JSIL.MethodSignature($.Boolean, [$.Char]), 
      StringParser_IsAlphaChar
    );

    $.Method({Static:true , Public:true }, "IsAlphaStr", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      StringParser_IsAlphaStr
    );

    $.Method({Static:true , Public:true }, "IsDigitChar", 
      new JSIL.MethodSignature($.Boolean, [$.Char]), 
      StringParser_IsDigitChar
    );

    $.Method({Static:true , Public:true }, "IsDigitStr", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      StringParser_IsDigitStr
    );

    $.Method({Static:true , Public:true }, "IsDomain", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      StringParser_IsDomain
    );

    $.Method({Static:true , Public:true }, "IsETCChar", 
      new JSIL.MethodSignature($.Boolean, [$.Char]), 
      StringParser_IsETCChar
    );

    $.Method({Static:true , Public:true }, "IsFindSqlInjuction", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      StringParser_IsFindSqlInjuction
    );

    $.Method({Static:true , Public:true }, "Left", 
      new JSIL.MethodSignature($.String, [$.String, $.Int32]), 
      StringParser_Left
    );

    $.Method({Static:true , Public:true }, "LogTrace", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $.Int32, $.Int32, 
          $.String
        ]), 
      StringParser_LogTrace$02
    );

    $.Method({Static:true , Public:true }, "LogTrace", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $.String, $.Int32, 
          $.Int32, $.String
        ]), 
      StringParser_LogTrace$03
    );

    $.Method({Static:true , Public:true }, "LogTrace", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $.Int32, $.String, 
          $.Int32, $.Int32, 
          $.String
        ]), 
      StringParser_LogTrace$04
    );

    $.Method({Static:true , Public:true }, "Mid", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.Int32
        ]), 
      StringParser_Mid$05
    );

    $.Method({Static:true , Public:true }, "Mid", 
      new JSIL.MethodSignature($.String, [$.String, $.Int32]), 
      StringParser_Mid$06
    );

    $.Method({Static:false, Public:true }, "Parse", 
      new JSIL.MethodSignature($.Int32, [$.String, $.String]), 
      StringParser_Parse
    );

    $.Method({Static:false, Public:true }, "RemoveAllParse", 
      JSIL.MethodSignature.Void, 
      StringParser_RemoveAllParse
    );

    $.Method({Static:true , Public:true }, "Replace", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.String, $.String
        ]), 
      StringParser_Replace
    );

    $.Method({Static:true , Public:true }, "Right", 
      new JSIL.MethodSignature($.String, [$.String, $.Int32]), 
      StringParser_Right
    );

    $.Method({Static:false, Public:true }, "SetParseAt", 
      new JSIL.MethodSignature(null, [$.Int32, $.String]), 
      StringParser_SetParseAt
    );

    $.Method({Static:true , Public:true }, "StringToChar", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Char]), [$.String, $jsilcore.TypeRef("JSIL.Reference", [$.Int32])]), 
      StringParser_StringToChar
    );

    $.Method({Static:true , Public:true }, "ToHexString", 
      new JSIL.MethodSignature($.String, [$.String]), 
      StringParser_ToHexString
    );

    $.Method({Static:true , Public:true }, "WildcardCompare", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String]), 
      StringParser_WildcardCompare
    );

    $.Method({Static:true , Public:true }, "WildcardCompareNoCase", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String]), 
      StringParser_WildcardCompareNoCase
    );

    $['Field']({Static:false, Public:false}, "m_aParse", $jsilcore.TypeRef("System.Array", [$.String])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum SuperString.StringParser+EventLogType */ 

JSIL.MakeEnum(
  {
    FullName: "SuperString.StringParser+EventLogType", 
    BaseType: $asm_mscorlib.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    eventlog_error_type: 1, 
    eventlog_warning_type: 2, 
    eventlog_information_type: 4, 
    eventlog_user_information_type: 32, 
    eventlog_timechk_type: 64, 
  }
);

